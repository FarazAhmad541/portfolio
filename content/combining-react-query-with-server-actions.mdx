---
title: "Supercharg Your React App: Combining React Query with Server Actions"
slug: "combining-react-query-with-server-actions"
date: "2023-10-15"
description: "Learn how to supercharge your React app by combining React Query with Server Actions. Discover optimization techniques, improved user experience, and simplified state management"
---

# Supercharg Your Next.Js App by Combining React Query with Server Actions.

React Query has long been a favorite tool for managing server state in React applications. With the introduction of Server Actions in React 18, we now have a powerful new way to handle server-side operations. In this blog post, we'll explore how to combine these two technologies to create more efficient and responsive React applications.

## What are Server Actions?

Server Actions, introduced in React 18, allow you to define server-side functions that can be called directly from your client-side React components. This approach simplifies the process of updating server state and provides a more seamless integration between client and server code.

## Why Use React Query with Server Actions?

While Server Actions are great for handling server-side operations, React Query excels at managing and caching client-side state. By combining these technologies, we can:

1.  Optimize data fetching and caching
2.  Improve user experience with instant UI updates
3.  Reduce network requests
4.  Simplify error handling and loading states

## Setting Up React Query with Server Actions

Let's walk through a basic setup:

#### First, install the necessary packages:

```bash
npm install @tanstack/react-query
```

#### Set up your React Query client:

```tsx showLineNumbers
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* Your app components */}
    </QueryClientProvider>
  )
}
```

#### Create a Server Action:

```tsx showLineNumbers 
'use server'

export async function addTodo(title) {
  // Add todo to database
  const newTodo = await db.todo.create({ title })
  return newTodo
}
```

#### Use React Query with the Server Action:

```tsx showLineNumbers {6-11}
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { addTodo } from './actions'

function AddTodoForm() {
  const queryClient = useQueryClient()
  const mutation = useMutation({
    mutationFn: addTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  const handleSubmit = (e) => {
    e.preventDefault()
    const title = e.target.title.value
    mutation.mutate(title)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" />
      <button type="submit">Add Todo</button>
    </form>
  )
}
```

## Benefits of This Approach

1. **Optimistic Updates**: React Query allows you to update the UI immediately, even before the server responds, providing a snappy user experience.

2. **Automatic Revalidation**: After a mutation, React Query can automatically refetch affected queries, ensuring your UI stays in sync with the server.

3. **Simplified Error Handling**: React Query provides built-in error handling, making it easy to display error states in your UI.

4. **Reduced Boilerplate**: By combining Server Actions with React Query, you can significantly reduce the amount of code needed to manage server state.

## Conclusion

Combining React Query with Server Actions creates a powerful synergy that can significantly improve the performance and user experience of your React applications. By leveraging the strengths of both technologies, you can create more responsive, efficient, and maintainable applications.

Remember, while this approach offers many benefits, it's important to consider your specific use case and application requirements when deciding on your state management strategy.

Happy coding!